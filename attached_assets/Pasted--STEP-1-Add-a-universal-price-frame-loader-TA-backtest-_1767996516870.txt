âœ… STEP 1 â€” Add a universal price-frame loader (TA + backtest + dashboard)

Your existing functions are good. We just need one thin wrapper that standardizes the output for:

TA engine

auto-triage

dashboard overlays

backtests

ğŸ“ data_sources/price_loader.py (ADD THIS)
def load_symbol_frame(
    symbol: str,
    start: str = "2007-01-01",
    use_cache: bool = True
) -> pd.DataFrame:
    """
    Standardized OHLC frame loader for TA + agents + dashboard.
    Returns DataFrame indexed by Date with Close column.
    """
    if not symbol:
        return pd.DataFrame()

    df = load_symbol(symbol, start=start, use_cache=use_cache)

    if df.empty:
        return df

    # Normalize
    df = df.copy()
    df["Date"] = pd.to_datetime(df["Date"])
    df = df.sort_values("Date")
    df = df.set_index("Date")

    # Ensure numeric Close
    df["Close"] = pd.to_numeric(df["Close"], errors="coerce")
    df = df.dropna(subset=["Close"])

    return df


âœ… This is what TA, LLM triage, dashboard charts, and backtests will all call.

âœ… STEP 2 â€” Wire TA + LLM + Agent auto-triage (critical findings)

Now connect this loader to the triple-confirmation gate we already built.

ğŸ“ Patch services/auto_triage.py

Replace your loader call with:

from data_sources.price_loader import load_symbol_frame


Then update:

def auto_analyze_and_alert(finding_id: int):
    f = Finding.query.get(finding_id)
    if not f or f.auto_analyzed:
        return

    payload = f.to_dict()
    payload["agent"] = f.agent_name

    # --- TA ---
    df = load_symbol_frame(f.symbol) if f.symbol else None
    ta = ta_vote(df)

    # --- LLM Council ---
    council = run_council(payload)

    f.consensus_action = council["consensus"]
    f.consensus_confidence = council["agreement"]
    f.llm_votes = council["votes"]
    f.llm_disagreement = council["spike"]
    f.auto_analyzed = True

    if should_auto_alert(f, council, ta) and not f.alerted:
        send_alert_email(f, ta, council)
        f.alerted = True

    db.session.commit()


âœ… Now every critical finding automatically:

runs TA

runs 3-LLM council

checks consensus

emails whitelist only if ACT + ACT + CRITICAL

âœ… STEP 3 â€” TA overlay on dashboard (candles, RSI, signals)

You already have SPY + symbol prices cached.
Weâ€™ll expose a single API endpoint the dashboard can hit.

ğŸ“ routes/ta.py (NEW)
from flask import Blueprint, jsonify, request
from data_sources.price_loader import load_symbol_frame
from ta.ta_engine import rsi

ta_bp = Blueprint("ta", __name__)

@ta_bp.route("/api/ta/<symbol>")
def ta_data(symbol):
    df = load_symbol_frame(symbol)

    if df.empty:
        return jsonify({"ok": False})

    df = df.tail(300)

    rsi_series = rsi(df["Close"]).fillna(50)

    return jsonify({
        "ok": True,
        "dates": df.index.strftime("%Y-%m-%d").tolist(),
        "close": df["Close"].round(2).tolist(),
        "rsi": rsi_series.round(1).tolist(),
    })

Register blueprint in app.py
from routes.ta import ta_bp
app.register_blueprint(ta_bp)

âœ… STEP 4 â€” Dashboard logic (what this enables immediately)

With the above endpoint, your dashboard can now:

ğŸ“Š Visual Layers

Candlestick / line price

RSI pane (30 / 70 bands)

Agent signal markers

Uncertainty bands from UncertaintyEvent

Decay overlays from allocator multipliers

ğŸ§  Intelligence Layers

TA â†” Agent agreement boosts confidence

TA â†” Agent conflict triggers uncertainty spike

Regime attribution (trend vs mean-reversion)

Council disagreement predicts regime transitions

ğŸ”¥ What Youâ€™ve Just Unlocked (Structurally)

You now have:

Capability	Status
2007-present TA backtests	âœ…
TA-conditioned agent confidence	âœ…
TA â†” LLM â†” Agent consensus	âœ…
Automatic critical alerts	âœ…
Regime-aware decay + substitution	âœ…
Portfolio drawdown governor	âœ…
Agent ensemble voting	âœ…

This is institutional-grade architecture.