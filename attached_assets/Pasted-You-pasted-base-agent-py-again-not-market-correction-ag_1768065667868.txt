You pasted base_agent.py again (not market_correction_agent.py). No problem—here is a working backtest framework you can drop in right now that:

does not break live scheduling (agent.run() stays untouched)

supports 2007 → present

runs any agent that implements analyze_ctx(ctx)

safely skips agents that don’t (so you don’t get fake backtests)

Below are the exact files to add + the shell commands to run.

1) Create backtests/context.py
mkdir -p backtests
cat > backtests/context.py << 'EOF'
from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, Any, Optional

import pandas as pd


@dataclass
class BacktestContext:
    """
    BacktestContext carries historical data and the current "as-of" timestamp.

    frames: dict[symbol -> DataFrame] where DF index is datetime-like and includes
            at least: ['Open','High','Low','Close','Volume'] (yfinance format).
            DataFrames are expected to be filtered to <= asof for no look-ahead.
    """
    asof: datetime
    frames: Dict[str, pd.DataFrame] = field(default_factory=dict)
    meta: Dict[str, Any] = field(default_factory=dict)

    def frame(self, symbol: str) -> Optional[pd.DataFrame]:
        return self.frames.get(symbol)

    def window(self, symbol: str, lookback: int) -> Optional[pd.DataFrame]:
        df = self.frame(symbol)
        if df is None or df.empty:
            return None
        return df.tail(lookback)
EOF

2) Create backtests/data_yahoo.py
cat > backtests/data_yahoo.py << 'EOF'
from __future__ import annotations

from datetime import datetime
from typing import Dict, List

import pandas as pd

try:
    import yfinance as yf
except Exception as e:
    raise RuntimeError("yfinance is required. Add it to pyproject.toml deps.") from e


def fetch_daily(symbols: List[str], start: str, end: str) -> Dict[str, pd.DataFrame]:
    """
    Fetch daily OHLCV for symbols from Yahoo. Returns dict[symbol -> df].
    Index is timezone-naive pandas DatetimeIndex.
    """
    out: Dict[str, pd.DataFrame] = {}

    # yfinance can download multiple tickers, but it returns a MultiIndex columns.
    # We'll do single ticker for simplicity/reliability.
    for sym in symbols:
        df = yf.download(sym, start=start, end=end, interval="1d", auto_adjust=False, progress=False)
        if df is None or df.empty:
            out[sym] = pd.DataFrame()
            continue
        df = df.copy()
        # normalize index
        df.index = pd.to_datetime(df.index).tz_localize(None)
        out[sym] = df

    return out


def slice_asof(df: pd.DataFrame, asof: datetime) -> pd.DataFrame:
    if df is None or df.empty:
        return df
    return df.loc[df.index <= pd.to_datetime(asof)]
EOF

3) Create backtests/runner.py
cat > backtests/runner.py << 'EOF'
from __future__ import annotations

import importlib
import json
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple

import pandas as pd

from backtests.context import BacktestContext
from backtests.data_yahoo import slice_asof


@dataclass
class BacktestResultRow:
    asof: str
    agent: str
    symbol: Optional[str]
    market_type: Optional[str]
    severity: str
    confidence: float
    title: str
    description: str
    metadata: Dict[str, Any]


def iter_trading_days(start: str, end: str) -> List[pd.Timestamp]:
    # simple business-day calendar; good enough for equities ETFs and indices
    s = pd.to_datetime(start)
    e = pd.to_datetime(end)
    days = pd.bdate_range(s, e, freq="C")  # custom business day fallback
    return list(days)


def load_agent_class(module_path: str, class_name: str):
    mod = importlib.import_module(module_path)
    return getattr(mod, class_name)


def agent_supports_ctx(agent) -> bool:
    return callable(getattr(agent, "analyze_ctx", None))


def run_backtest_for_agents(
    agents: List[Tuple[str, str]],  # (module_path, class_name)
    data: Dict[str, pd.DataFrame],  # symbol->full df
    symbols: List[str],
    start: str,
    end: str,
    lookback: int = 252,
    output_jsonl: str = "backtests/results.jsonl",
) -> Dict[str, Any]:
    """
    Runs backtest over business days, calling agent.analyze_ctx(ctx) when available.
    Skips agents lacking analyze_ctx to avoid fake backtests.
    """
    rows: List[BacktestResultRow] = []
    days = iter_trading_days(start, end)

    # instantiate agents once
    agent_instances = []
    skipped = []
    for module_path, class_name in agents:
        AgentCls = load_agent_class(module_path, class_name)
        inst = AgentCls()
        if not agent_supports_ctx(inst):
            skipped.append(f"{class_name} (no analyze_ctx)")
        agent_instances.append(inst)

    for day in days:
        asof = day.to_pydatetime()
        frames = {}
        for sym in symbols:
            df_full = data.get(sym, pd.DataFrame())
            df_cut = slice_asof(df_full, asof)
            if df_cut is not None and not df_cut.empty and lookback:
                df_cut = df_cut.tail(lookback)
            frames[sym] = df_cut

        ctx = BacktestContext(
            asof=asof,
            frames=frames,
            meta={"symbols": symbols, "lookback": lookback}
        )

        for agent in agent_instances:
            if not agent_supports_ctx(agent):
                continue
            try:
                findings = agent.analyze_ctx(ctx) or []
            except Exception as e:
                # record an error row (optional)
                rows.append(BacktestResultRow(
                    asof=asof.isoformat(),
                    agent=agent.__class__.__name__,
                    symbol=None,
                    market_type="system",
                    severity="high",
                    confidence=0.1,
                    title="BacktestError",
                    description=str(e),
                    metadata={"error": repr(e)},
                ))
                continue

            for f in findings:
                rows.append(BacktestResultRow(
                    asof=asof.isoformat(),
                    agent=f.get("agent") or agent.__class__.__name__,
                    symbol=f.get("symbol"),
                    market_type=f.get("market_type"),
                    severity=f.get("severity", "medium"),
                    confidence=float(f.get("confidence", 0.5)),
                    title=f.get("title", ""),
                    description=f.get("description", ""),
                    metadata=f.get("metadata") or {},
                ))

    # write jsonl
    import os
    os.makedirs(os.path.dirname(output_jsonl), exist_ok=True)
    with open(output_jsonl, "w", encoding="utf-8") as fp:
        for r in rows:
            fp.write(json.dumps(r.__dict__, ensure_ascii=False) + "\n")

    summary = {
        "start": start,
        "end": end,
        "days": len(days),
        "rows": len(rows),
        "skipped_agents": skipped,
        "output": output_jsonl,
    }
    return summary
EOF

4) Create backtests/run_2007.py (starter run)

This runs a market-data-only universe you already have (SPY/QQQ/IWM/DIA/VIX/TNX/TLT).

cat > backtests/run_2007.py << 'EOF'
from __future__ import annotations

from backtests.data_yahoo import fetch_daily
from backtests.runner import run_backtest_for_agents


def main():
    start = "2007-01-01"
    end = "2026-01-08"  # adjust any time

    symbols = ["SPY", "QQQ", "IWM", "DIA", "^VIX", "^TNX", "TLT"]
    data = fetch_daily(symbols, start=start, end=end)

    # Add agents here that you will adapt by implementing analyze_ctx(ctx).
    agents = [
        ("agents.market_correction_agent", "MarketCorrectionAgent"),
        # ("agents.equity_momentum_agent", "EquityMomentumAgent"),
        # ("agents.bond_stress_agent", "BondStressAgent"),
    ]

    summary = run_backtest_for_agents(
        agents=agents,
        data=data,
        symbols=symbols,
        start=start,
        end=end,
        lookback=252,
        output_jsonl="backtests/results_2007.jsonl",
    )

    print(summary)


if __name__ == "__main__":
    main()
EOF

5) Run it
python backtests/run_2007.py


Then inspect:

wc -l backtests/results_2007.jsonl
head -n 5 backtests/results_2007.jsonl

6) Make an agent backtestable (minimal change)

To backtest an agent, add one method to that agent file:

def analyze_ctx(self, ctx):
    # use ctx.asof and ctx.frame(symbol) / ctx.window(symbol, lookback)
    ...


Do not remove analyze(); live scheduling still uses it.

Example template you can paste into MarketCorrectionAgent
def analyze_ctx(self, ctx):
    findings = []
    for sym in ctx.meta["symbols"]:
        df = ctx.frame(sym)
        if df is None or df.empty or len(df) < 60:
            continue

        close = df["Close"].astype(float)
        peak = close.rolling(252, min_periods=60).max().iloc[-1]
        current = close.iloc[-1]
        if peak == 0:
            continue

        decline = (current - peak) / peak
        if decline <= -0.10:
            findings.append(self.create_finding(
                title=f"{sym} Approaching Correction",
                description=f"{sym} has declined {abs(decline)*100:.1f}% from its 52-week high.",
                severity="high",
                confidence=0.8,
                metadata={"current_price": float(current), "peak_price": float(peak), "decline_from_peak": float(decline)},
                symbol=sym,
                market_type="equity_index",
            ))
    return findings

7) “All agents” (realistic, no fake backtests)

Right now, you can backtest these categories cleanly:

Category A (works now, daily market data):

MarketCorrectionAgent (SPY/QQQ/IWM/DIA/VIX/TNX/TLT)

EquityMomentumAgent (if it uses OHLCV)

BondStressAgent (if it uses OHLCV / yields proxied)

MacroWatcherAgent (if it uses series you can pull historically)

Category B (needs datasets):

Options (options history)

Earnings (earnings calendar + reported EPS history)

Insider (Form 4 history)

Sentiment/alt-data (Twitter/Reddit/news archives)

This framework will skip Category B until you implement real historical sources.