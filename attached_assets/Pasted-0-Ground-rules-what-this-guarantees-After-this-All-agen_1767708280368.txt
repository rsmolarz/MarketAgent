0ï¸âƒ£ Ground rules (what this guarantees)

After this:

âœ… All agent controls live under /admin/â€¦

âœ… No agent can write to main

âœ… Every change is:

Proposed â†’ Diffed â†’ Risk-scored â†’ Voted â†’ Approved â†’ Merged

âœ… Admin sees

Diffs

â€œWhy this changeâ€

Per-file risk

Multi-agent votes

Merge button

âœ… Public users never see agents

âœ… Rejected ideas are remembered and avoided

1ï¸âƒ£ Folder structure (unchanged, clarified)

You already have this shape (good):

app/
â”œâ”€â”€ app.py                (or app/app.py)
â”œâ”€â”€ agent_routes.py
â”œâ”€â”€ agent_store.py
â”œâ”€â”€ agent_runner.py
â”œâ”€â”€ risk_scoring.py
â”œâ”€â”€ diff_render.py
â”œâ”€â”€ pdf_heatmap.py
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ agent_dashboard.html
â”‚   â”œâ”€â”€ agent_proposal_detail.html
â”‚   â””â”€â”€ admin_layout.html   â† we add this

2ï¸âƒ£ Admin-only blueprint (single source of truth)

Everything agent-related lives in one blueprint:

agent_bp = Blueprint(
    "agent",
    __name__,
    url_prefix="/admin/agents"
)


So all routes are:

/admin/agents
/admin/agents/proposals/<id>
/admin/agents/proposals/<id>/run-votes
/admin/agents/proposals/<id>/approve-merge
/admin/agents/proposals/<id>/reject

3ï¸âƒ£ How to register the blueprint (A / B / C)
âœ… CASE A â€” app.py at repo root
# app.py
from flask import Flask
from app.agent_routes import agent_bp

app = Flask(__name__)
app.register_blueprint(agent_bp)

âœ… CASE B â€” app/app.py
# app/app.py
from flask import Flask
from app.agent_routes import agent_bp

app = Flask(__name__)
app.register_blueprint(agent_bp)

âœ… CASE C â€” application factory (create_app())
# app/__init__.py
from flask import Flask
from app.agent_routes import agent_bp

def create_app():
    app = Flask(__name__)

    app.register_blueprint(agent_bp)

    return app


ğŸ”’ This is the safest option long-term â€” agents stay isolated and testable.

4ï¸âƒ£ Lock agents behind admin auth (critical)

In agent_routes.py, add one decorator:

from functools import wraps
from flask import abort
from flask_login import current_user

def admin_required(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.is_admin:
            abort(403)
        return f(*args, **kwargs)
    return wrapper


Then apply it once:

@agent_bp.before_request
@admin_required
def protect_admin_agents():
    pass


âœ… This automatically protects every agent route.

5ï¸âƒ£ Admin UI layout (single dashboard shell)

Create templates/admin_layout.html

<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>{% block title %}Admin{% endblock %}</title>
  <style>
    body { font-family: system-ui; margin: 0; }
    nav {
      background: #2b2e4a;
      color: #fff;
      padding: 12px 20px;
      display: flex;
      gap: 16px;
    }
    nav a {
      color: #fff;
      text-decoration: none;
      font-weight: 600;
    }
    main { padding: 24px; }
  </style>
</head>
<body>
  <nav>
    <a href="/admin">Admin Home</a>
    <a href="/admin/agents">AI Oversight</a>
    <a href="/admin/cases">Cases</a>
    <a href="/admin/contracts">Contracts</a>
  </nav>

  <main>
    {% block content %}{% endblock %}
  </main>
</body>
</html>


Then update both:

{% extends "admin_layout.html" %}
{% block content %}
...
{% endblock %}


Now the Agent Dashboard is first-class Admin UI, not a bolt-on.

6ï¸âƒ£ Where the agent actually â€œbuildsâ€ code (important)

Right now your UI monitors risk.

To make the agent actively propose improvements, you add one controlled entry point:

/admin/agents/autobuild
@agent_bp.post("/autobuild")
def autobuild():
    """
    Builder Agent proposes a change.
    NEVER touches main.
    """
    goal = request.form["goal"]

    branch = f"agent/{uuid.uuid4().hex[:8]}"
    subprocess.run(["git", "checkout", "-b", branch], check=True)

    # Builder agent proposes changes
    proposal = run_builder_agent(goal)

    # Apply changes â†’ compute diff
    diff = get_git_diff()

    # Risk scoring
    file_risk, overall_risk = score_diff(diff)

    # Store proposal
    pid = uuid.uuid4().hex
    store_proposal(
        pid=pid,
        branch=branch,
        title=proposal["title"],
        summary=proposal["summary"],
        rationale=proposal["rationale"],
        unified_diff=diff,
        overall_risk=overall_risk,
        file_risk=file_risk
    )

    return redirect(f"/admin/agents/proposals/{pid}")


âœ… Agent never merges
âœ… Agent never touches main
âœ… Human always decides

7ï¸âƒ£ Oversight logic (who can approve)

A proposal can only merge if:

Requirement	Enforced
Validator approves	âœ…
Compliance approves	âœ…
Risk < threshold	âœ…
Tests pass	âœ…
Human clicks merge	âœ…

This is already enforced in the merge route.