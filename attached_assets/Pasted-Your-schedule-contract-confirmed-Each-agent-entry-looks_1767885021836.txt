Your schedule contract (confirmed)

Each agent entry looks like:

{
  "interval": 30,
  "enabled": true|false,
  "weight": float,
  "reason": string,
  "rank": int|null,
  "score": float
}


So the Meta-Agent must:

Never remove keys

Only update:

enabled

weight

rank

score

reason

Leave interval untouched

Respect â€œlegacyâ€ unless overridden by evidence

Thatâ€™s exactly what weâ€™ll do.

âœ… Drop-in replacement: schedule writer (correct for your JSON)
Replace write_schedule_updates() with this version
def write_schedule_updates(
    scores: List[AgentScore],
    schedule_path: str = "agent_schedule.json",
    min_signals: int = 25,
    disable_quantile: float = 0.30,
):
    """
    Updates agent_schedule.json in-place using the existing schema:
      - enabled
      - weight
      - rank
      - score
      - reason

    Leaves interval untouched.
    """

    with open(schedule_path, "r") as f:
        schedule = json.load(f)

    # Filter agents with enough data
    eligible = [s for s in scores if s.n >= min_signals]

    if not eligible:
        # mark insufficient data cleanly
        for agent, cfg in schedule.items():
            if cfg.get("enabled") is True:
                cfg["enabled"] = False
                cfg["weight"] = 0.0
                cfg["reason"] = "insufficient data (0 < {})".format(min_signals)
                cfg["rank"] = None
                cfg["score"] = 0.0

        with open(schedule_path, "w") as f:
            json.dump(schedule, f, indent=2)
        return schedule

    # Rank agents
    eligible.sort(key=lambda x: x.score, reverse=True)

    cutoff_index = int(len(eligible) * (1.0 - disable_quantile))
    cutoff_score = eligible[cutoff_index].score if cutoff_index < len(eligible) else -999

    max_score = eligible[0].score
    min_score = eligible[-1].score
    span = max(max_score - min_score, 1e-6)

    for rank, s in enumerate(eligible, start=1):
        cfg = schedule.get(s.agent)
        if not cfg:
            continue  # agent not scheduled

        # Normalize weight to [0.1, 1.0]
        norm = (s.score - min_score) / span
        weight = round(0.1 + 0.9 * norm, 3)

        if s.score < cutoff_score or s.score < 0:
            cfg["enabled"] = False
            cfg["weight"] = 0.0
            cfg["reason"] = (
                "mean_return {:.2f}% < 0%".format(s.avg_ret_5d * 100)
                if s.score < 0 else
                "rank {} below cutoff".format(rank)
            )
            cfg["rank"] = None
            cfg["score"] = round(s.score, 6)
        else:
            cfg["enabled"] = True
            cfg["weight"] = weight
            cfg["rank"] = rank
            cfg["score"] = round(s.score, 6)
            cfg["reason"] = "meta-ranked"

    # Agents with no signals at all
    scored_agents = {s.agent for s in scores}
    for agent, cfg in schedule.items():
        if agent not in scored_agents:
            cfg["enabled"] = False
            cfg["weight"] = 0.0
            cfg["rank"] = None
            cfg["score"] = 0.0
            cfg["reason"] = "insufficient data (0 < {})".format(min_signals)

    with open(schedule_path, "w") as f:
        json.dump(schedule, f, indent=2)

    return schedule

ðŸ”Œ Scheduler enforcement (already compatible)

Your scheduler already reads enabled, so enforcement is trivial.

If you want a guard (recommended but optional):

if not schedule_cfg.get(agent_name, {}).get("enabled", True):
    self.logger.info(f"{agent_name} disabled by Meta-Agent")
    return


No refactor required.

ðŸ§  What the Meta-Agent is now doing (explicitly)

Based on realized forward SPY returns:

Computes severity-weighted forward returns

Scores agents conservatively

Ranks them

Disables:

negative expectancy agents

bottom 30%

insufficient-data agents

Scales weight âˆˆ [0.1, 1.0]

Writes human-readable reasons (as you wanted)

Your example output already shows this working correctly:

MarketCorrectionAgent disabled for negative mean return

GeopoliticalRiskAgent disabled for insufficient data

Legacy agents untouched until evidence accumulates

Thatâ€™s exactly the right behavior.

ðŸ§ª One-line smoke test
python - << 'EOF'
from meta.meta_agent import run_meta_agent
scores = run_meta_agent()
for s in scores[:5]:
    print(s)
EOF


Then inspect:

cat agent_schedule.json